# ADR 001: Migration from Python Script to TypeScript Web Application

Date: 2025-09-25
Status: Proposed
Decision Makers: Team

## Context
The existing Python script (`charge_calculator.py`) mixes responsibilities: GUI (tkinter), file parsing for two formats (XLSX, EDF), domain assembly, and charge calculation. This violates Single Responsibility Principle and impedes extension. We need a browser-based interface with responsiveness, MIME type validation, and scalable parsing (large EDF file ~132k lines). The goal: modern web app using Vite + TypeScript + Zod + Web Worker.

## Decision
Rebuild as a TypeScript single-page application with:
- Vite for fast dev/build
- TypeScript for type safety
- Zod for runtime validation of parsed structures
- Web Worker for heavy parsing and computation off the main thread
- Modular architecture separating parsing, domain assembly, validation, calculation, and UI

## Rationale
- SRP: Each layer has clear ownership (extract tokens, assemble domain, validate, calculate, present)
- Performance: Large EDF parsing offloads to worker to avoid UI freeze
- Reliability: Zod ensures external file data integrity before calculations
- Extensibility: Adding new formats requires only a new token extractor + detection rule
- Maintainability: Domain logic decoupled from UI libraries

## Architecture Overview
```
File -> detectMime -> (xlsx|edf) tokenExtractor -> tokens -> assemble (domain) -> zod validate -> enrich (charge per step + totals) -> UI table/export
```
Worker boundary encloses: detectMime, tokenExtractor, assemble, validate, enrich.

## Alternatives Considered
1. Keep Python backend + thin JS UI: Rejected (adds server complexity, still have mixed parsing code)
2. WASM port of Python logic: Rejected (unnecessary overhead; logic is simple to reimplement in TS)
3. Parse on main thread: Rejected (EDF size causes potential UI blocking)

## Consequences
- Initial rewrite cost.
- Need JS XLSX parsing library (SheetJS) increasing bundle size (~200KB) but acceptable.
- Must implement EDF text parser carefully for large files (stream/line iteration).

## Decision Details
- Output data model: `ParsedResult { cycles: Cycle[] }` with `Cycle { cycle:number; steps: Step[] }` and `Step { step:number; dp: DataPoint[] }`.
- Charge algorithm: identical to Python reference (reuse logic semantics for regression parity).
- Validation enforced after assembly; failure halts UI update with explicit error message.
- MIME detection uses both `File.type` and magic bytes.

## Open Questions
- Do we need localization / i18n? (Pending)
- Add zustand/store now or later? (Defer until state grows beyond simple) 
- Export XLSX support? (Phase 2)

## Follow-Up ADRs
- ADR 002: State management decision (if/when adding global store)
- ADR 003: Export formats expansion

## References
- Existing Python file `charge_calculator.py`
- Sample EDF `222-23-40.edf`
